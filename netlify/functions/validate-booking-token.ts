import { Handler } from '@netlify/functions';
import { PrismaClient } from '@prisma/client';
import { z } from 'zod';
import crypto from 'crypto';
import { createResponse, createCorsResponse, createErrorResponse } from '../../lib/netlify-helpers';

const prisma = new PrismaClient({
  log: ['error', 'warn'],
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  }
});

const JWT_SECRET = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET;

// Token validation request schema
const tokenValidationSchema = z.object({
  token: z.string().min(1, 'Token is required'),
});

interface DecodedToken {
  leadId: string;
  contactId?: string;
  email: string;
  serviceArea?: string;
  isInServiceArea: boolean;
  expiresAt: number;
  iat: number;
}

/**
 * Booking Token Validation Function
 * 
 * Validates JWT tokens generated by the GoHighLevel webhook
 * and returns associated lead information for the booking process.
 * 
 * Features:
 * - JWT token signature validation
 * - Token expiration checking
 * - Lead data retrieval and validation
 * - Service area eligibility verification
 * - Security logging and monitoring
 * 
 * Endpoint: /.netlify/functions/validate-booking-token
 * Methods: GET, POST
 * 
 * GET Query params:
 * - token (required): JWT token to validate
 * 
 * POST Body:
 * {
 *   "token": "jwt_token_here"
 * }
 * 
 * Response:
 * {
 *   "valid": true,
 *   "lead": {
 *     "id": "lead_uuid",
 *     "name": "Jan Jansen",
 *     "email": "jan@example.nl",
 *     "phone": "06-12345678",
 *     "address": "Hoofdstraat 123, 6211 AB Maastricht"
 *   },
 *   "serviceArea": {
 *     "isEligible": true,
 *     "region": "Limburg"
 *   },
 *   "tokenInfo": {
 *     "issuedAt": "2024-01-15T10:00:00Z",
 *     "expiresAt": "2024-01-16T10:00:00Z",
 *     "remainingTime": 86400000
 *   }
 * }
 */
export const handler: Handler = async (event) => {
  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return createCorsResponse('GET, POST, OPTIONS');
  }

  // Allow both GET and POST requests
  if (!['GET', 'POST'].includes(event.httpMethod || '')) {
    return createErrorResponse(405, 'Method not allowed', {
      allowedMethods: ['GET', 'POST', 'OPTIONS']
    });
  }

  const startTime = Date.now();
  let tokenData: string | null = null;

  try {
    // Validate required environment variables
    if (!JWT_SECRET) {
      console.error('Missing JWT_SECRET environment variable');
      return createErrorResponse(500, 'Server configuration error');
    }

    // Parse request data
    let requestData: any;
    if (event.httpMethod === 'GET') {
      const params = event.queryStringParameters || {};
      requestData = {
        token: params.token || '',
      };
    } else {
      // POST request
      if (!event.body) {
        return createErrorResponse(400, 'Request body is required for POST requests');
      }

      try {
        requestData = JSON.parse(event.body);
      } catch (parseError) {
        return createErrorResponse(400, 'Invalid JSON in request body', {
          details: 'Request body must be valid JSON'
        });
      }
    }

    // Validate request data
    let validatedData;
    try {
      validatedData = tokenValidationSchema.parse(requestData);
    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        return createErrorResponse(400, 'Validation error', {
          details: validationError.issues.map(issue => ({
            field: issue.path.join('.'),
            message: issue.message,
            code: issue.code,
          }))
        });
      }
      throw validationError;
    }

    tokenData = validatedData.token;

    // Validate and decode JWT token
    const decodedToken = validateJWTToken(tokenData, JWT_SECRET);
    if (!decodedToken) {
      return createErrorResponse(401, 'Invalid or expired token', {
        message: 'The booking token is invalid, expired, or has been tampered with',
        action: 'Please request a new booking link'
      });
    }

    // Check token expiration
    const now = Math.floor(Date.now() / 1000);
    if (decodedToken.expiresAt <= now) {
      console.warn('Expired token access attempt', {
        leadId: decodedToken.leadId,
        expiresAt: new Date(decodedToken.expiresAt * 1000).toISOString(),
        now: new Date().toISOString()
      });

      return createErrorResponse(401, 'Token expired', {
        message: 'The booking token has expired',
        expiredAt: new Date(decodedToken.expiresAt * 1000).toISOString(),
        action: 'Please request a new booking link'
      });
    }

    // Retrieve lead data from database
    const lead = await prisma.lead.findUnique({
      where: { id: decodedToken.leadId },
      select: {
        id: true,
        naam: true,
        email: true,
        telefoon: true,
        adres: true,
        postcode: true,
        stad: true,
        // TODO: Enable after migration
        // provincie: true,
        // isInServiceArea: true,
        // status: true,
        // bronSysteem: true,
        // tags: true,
        // customFields: true,
        notities: true,
        createdAt: true,
        // TODO: Enable after migration
        // lastContactAt: true,
      }
    });

    if (!lead) {
      console.error('Lead not found for valid token', {
        leadId: decodedToken.leadId,
        tokenEmail: decodedToken.email
      });

      return createErrorResponse(404, 'Lead not found', {
        message: 'The lead associated with this token could not be found',
        leadId: decodedToken.leadId
      });
    }

    // Verify token data matches lead data
    if (lead.email !== decodedToken.email) {
      console.error('Token email mismatch', {
        leadId: lead.id,
        tokenEmail: decodedToken.email,
        leadEmail: lead.email
      });

      return createErrorResponse(401, 'Token data mismatch', {
        message: 'Token validation failed due to data inconsistency'
      });
    }

    // TODO: Update last contact time after migration
    // await prisma.lead.update({
    //   where: { id: lead.id },
    //   data: { 
    //     lastContactAt: new Date(),
    //     status: lead.status === 'nieuw' ? 'geÃ¯nteresseerd' : lead.status
    //   }
    // });

    // Prepare response
    const response = {
      valid: true,
      lead: {
        id: lead.id,
        name: lead.naam,
        email: lead.email,
        phone: lead.telefoon,
        address: lead.adres && lead.postcode && lead.stad 
          ? `${lead.adres}, ${lead.postcode} ${lead.stad}`
          : null,
        location: {
          address: lead.adres,
          postalCode: lead.postcode,
          city: lead.stad,
          province: 'Unknown', // TODO: Enable after migration
        },
        source: 'Unknown', // TODO: Enable after migration
        tags: [], // TODO: Enable after migration
        customFields: {}, // TODO: Enable after migration
      },
      serviceArea: {
        isEligible: true, // TODO: Enable after migration
        region: 'Unknown', // TODO: Enable after migration
        validation: 'Service available in your area' // TODO: Enable after migration
      },
      tokenInfo: {
        issuedAt: new Date(decodedToken.iat * 1000).toISOString(),
        expiresAt: new Date(decodedToken.expiresAt * 1000).toISOString(),
        remainingTime: (decodedToken.expiresAt - now) * 1000, // milliseconds
        contactId: decodedToken.contactId,
      },
      metadata: {
        processingTime: Date.now() - startTime,
        leadLastContact: null, // TODO: Enable after migration
        leadCreated: lead.createdAt.toISOString(),
      }
    };

    console.info('Token validated successfully', {
      leadId: lead.id,
      email: lead.email,
      isInServiceArea: true, // TODO: Enable after migration
      remainingTime: (decodedToken.expiresAt - now) * 1000,
      processingTime: Date.now() - startTime
    });

    return createResponse(200, response, {
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'X-Lead-ID': lead.id,
      'X-Processing-Time': `${Date.now() - startTime}ms`,
    });

  } catch (error) {
    console.error('Token validation error:', error);

    // Log detailed error information
    const errorDetails = {
      message: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined,
      tokenProvided: !!tokenData,
      tokenLength: tokenData?.length || 0,
      timestamp: new Date().toISOString(),
      processingTime: Date.now() - startTime,
    };

    console.error('Token validation error details:', errorDetails);

    return createErrorResponse(500, 'Token validation failed', {
      message: 'An error occurred while validating the booking token. Please try again later.',
      requestId: `token_${Date.now()}`,
    });
  } finally {
    await prisma.$disconnect();
  }
};

/**
 * Validate JWT token and return decoded payload
 */
function validateJWTToken(token: string, secret: string): DecodedToken | null {
  try {
    // Split token into parts
    const parts = token.split('.');
    if (parts.length !== 3) {
      return null;
    }

    const [header, payload, signature] = parts;

    // Verify signature
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(`${header}.${payload}`)
      .digest('base64url');

    if (signature !== expectedSignature) {
      console.warn('JWT signature validation failed');
      return null;
    }

    // Decode and parse payload
    const decodedPayload = JSON.parse(
      Buffer.from(payload, 'base64url').toString('utf8')
    );

    // Validate required fields
    if (!decodedPayload.leadId || !decodedPayload.email || !decodedPayload.expiresAt) {
      console.warn('JWT payload missing required fields', {
        hasLeadId: !!decodedPayload.leadId,
        hasEmail: !!decodedPayload.email,
        hasExpiresAt: !!decodedPayload.expiresAt
      });
      return null;
    }

    return {
      leadId: decodedPayload.leadId,
      contactId: decodedPayload.contactId,
      email: decodedPayload.email,
      serviceArea: decodedPayload.serviceArea,
      isInServiceArea: decodedPayload.isInServiceArea || false,
      expiresAt: decodedPayload.expiresAt,
      iat: decodedPayload.iat || Math.floor(Date.now() / 1000),
    };

  } catch (error) {
    console.error('JWT token parsing error:', error);
    return null;
  }
}